<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>çœŸçˆ±ç²‰ç®¡ç†</title>
    <link rel="stylesheet" href="/static/styles.css">
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
</head>
<body>
    <div id="app">
        <!-- Toast Container -->
        <div class="toast-container">
            <div 
                v-for="toast in toasts" 
                :key="toast.id" 
                :class="['toast', toast.type]"
            >
                {{ toast.message }}
            </div>
        </div>
        
        <!-- Header -->
        <header class="header">
            <div class="header-content">
                <h1>ğŸ“¡ <span>çœŸçˆ±ç²‰</span>ç®¡ç†</h1>
                <div class="header-actions">
                    <button 
                        :class="['btn', 'btn-sm', activeTab === 'list' ? 'btn-primary' : 'btn-outline-light']"
                        @click="switchTab('list')"
                    >
                        ğŸ“‹ åˆ—è¡¨
                    </button>
                    <button 
                        :class="['btn', 'btn-sm', activeTab === 'logs' ? 'btn-primary' : 'btn-outline-light']"
                        @click="switchTab('logs')"
                    >
                        ğŸ“ æ—¥å¿—
                    </button>
                </div>
            </div>
        </header>
        
        <!-- List Page -->
        <template v-if="activeTab === 'list'">
            <!-- Summary Bar -->
            <div class="summary-bar">
                <div class="summary-content">
                    <div class="summary-stats">
                        <div class="stat-item">
                            <span class="stat-dot healthy"></span>
                            <span class="stat-label">å¥åº·</span>
                            <span class="stat-value">{{ summary.healthy }}</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-dot unhealthy"></span>
                            <span class="stat-label">å¼‚å¸¸</span>
                            <span class="stat-value">{{ summary.unhealthy }}</span>
                        </div>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-outline btn-sm" @click="refreshAll" :disabled="loading">
                            {{ loading ? 'åˆ·æ–°ä¸­...' : 'åˆ·æ–°' }}
                        </button>
                        <button class="btn btn-secondary btn-sm" @click="resetAll" :disabled="loading">
                            é‡ç½®
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- List -->
            <div class="list-container">
                <div class="list-header">
                    <span class="list-title">ç›‘å¬åˆ—è¡¨ ({{ listeners.length }})</span>
                </div>
                
                <!-- Loading -->
                <div v-if="loading && listeners.length === 0" class="loading">
                    <div class="spinner"></div>
                    <p>åŠ è½½ä¸­...</p>
                </div>
                
                <!-- List Content -->
                <div v-else class="listener-list">
                    <!-- Listener Items -->
                    <div 
                        v-for="item in listeners" 
                        :key="item.chat" 
                        class="listener-item"
                    >
                        <div class="listener-info">
                            <span :class="['status-indicator', item.status]"></span>
                            <div class="listener-details">
                                <div class="listener-name">{{ item.chat }}</div>
                                <div :class="['listener-status', item.status]">
                                    {{ item.status === 'healthy' ? 'è¿è¡Œæ­£å¸¸' : (item.reason || 'çŠ¶æ€å¼‚å¸¸') }}
                                </div>
                            </div>
                        </div>
                        <div class="listener-actions">
                            <button 
                                class="btn btn-secondary btn-sm" 
                                @click="testAlive(item.chat)"
                                :disabled="loadingItems[item.chat]"
                            >
                                {{ loadingItems[item.chat] === 'test' ? 'æµ‹è¯•ä¸­...' : 'æµ‹æ´»' }}
                            </button>
                            <button 
                                class="btn btn-outline btn-sm" 
                                @click="resetOne(item.chat)"
                                :disabled="loadingItems[item.chat]"
                            >
                                {{ loadingItems[item.chat] === 'reset' ? 'é‡ç½®ä¸­...' : 'é‡ç½®' }}
                            </button>
                            <button 
                                class="btn btn-danger btn-sm" 
                                @click="removeOne(item.chat)"
                                :disabled="loadingItems[item.chat]"
                            >
                                {{ loadingItems[item.chat] === 'remove' ? 'åˆ é™¤ä¸­...' : 'åˆ é™¤' }}
                            </button>
                        </div>
                    </div>
                    
                    <!-- Add Card -->
                    <div class="add-card" @click="showAddModal = true">
                        <span>â•</span>
                        <span>æ·»åŠ ç›‘å¬</span>
                    </div>
                </div>
                
                <!-- Empty State (when not loading and no items) -->
                <div v-if="!loading && listeners.length === 0" class="empty-state">
                    <div class="empty-icon">ğŸ“­</div>
                    <p class="empty-text">æš‚æ— ç›‘å¬è®°å½•</p>
                </div>
            </div>
        </template>
        
        <!-- Logs Page -->
        <template v-else-if="activeTab === 'logs'">
            <div class="logs-container">
                <div class="logs-header">
                    <div class="logs-controls">
                        <!-- Service Tabs -->
                        <div class="service-tabs">
                            <button 
                                v-for="svc in services" 
                                :key="svc.key"
                                :class="['service-tab', { active: activeService === svc.key }]"
                                @click="switchService(svc.key)"
                            >
                                {{ svc.label }}
                            </button>
                        </div>
                        
                        <select v-model="logType" class="log-type-select" @change="switchLogType">
                            <option value="info">INFO</option>
                            <option value="error">ERROR</option>
                        </select>
                        
                        <button class="btn btn-outline btn-xs" @click="clearCurrentLogs" title="æ¸…ç©ºæ˜¾ç¤º">
                            æ¸…ç©º
                        </button>
                        <button class="btn btn-danger btn-xs" @click="truncateLogFile" :disabled="truncating" title="æ¸…ç©ºæœåŠ¡ç«¯æ—¥å¿—æ–‡ä»¶">
                            {{ truncating ? '...' : 'ğŸ—‘ï¸' }}
                        </button>
                    </div>
                    <div class="logs-info">
                        <span>
                            <span :class="['poll-indicator', { paused: !isPolling }]"></span>
                            {{ isPolling ? 'è½®è¯¢ä¸­' : 'å·²æš‚åœ' }}
                        </span>
                        <span>{{ currentLogLines.length }} è¡Œ</span>
                    </div>
                </div>
                
                <div class="logs-content" ref="logsContainer" @scroll="handleLogsScroll">
                    <template v-if="currentLogLines.length > 0">
                        <div 
                            v-for="(line, index) in currentLogLines" 
                            :key="index"
                            :class="['log-line', getLogLevel(line)]"
                        >{{ line }}</div>
                    </template>
                    <div v-else class="logs-empty">
                        <div class="logs-empty-icon">ğŸ“œ</div>
                        <p>{{ logsLoading ? 'åŠ è½½ä¸­...' : 'æš‚æ— æ—¥å¿—' }}</p>
                    </div>
                </div>
                
                <!-- Auto scroll button -->
                <button 
                    :class="['auto-scroll-btn', { active: autoScroll }]"
                    @click="toggleAutoScroll"
                    :title="autoScroll ? 'è‡ªåŠ¨æ»šåŠ¨å¼€å¯' : 'è‡ªåŠ¨æ»šåŠ¨å…³é—­'"
                >
                    â¬‡ï¸
                </button>
            </div>
        </template>
        
        
        <!-- Add Modal -->
        <div v-if="showAddModal" class="modal-overlay" @click.self="showAddModal = false">
            <div class="modal">
                <h3 class="modal-title">æ·»åŠ ç›‘å¬</h3>
                <input 
                    v-model="newChatName" 
                    class="modal-input" 
                    placeholder="è¯·è¾“å…¥èŠå¤©åç§°ï¼ˆå¥½å‹æ˜µç§°æˆ–ç¾¤åï¼‰"
                    @keyup.enter="addListener"
                    ref="addInput"
                />
                <div class="modal-actions">
                    <button class="btn btn-outline" @click="showAddModal = false">å–æ¶ˆ</button>
                    <button class="btn btn-primary" @click="addListener" :disabled="!newChatName.trim() || addLoading">
                        {{ addLoading ? 'æ·»åŠ ä¸­...' : 'ç¡®è®¤æ·»åŠ ' }}
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Confirm Modal -->
        <div v-if="confirmModal.show" class="modal-overlay" @click.self="confirmModal.show = false">
            <div class="modal">
                <h3 class="modal-title">{{ confirmModal.title }}</h3>
                <p class="modal-message">{{ confirmModal.message }}</p>
                <div class="modal-actions">
                    <button class="btn btn-outline" @click="confirmModal.show = false">å–æ¶ˆ</button>
                    <button class="btn btn-danger" @click="confirmModal.onConfirm">ç¡®è®¤</button>
                </div>
            </div>
        </div>
        
        <!-- Test Alive Result Modal -->
        <div v-if="testAliveModal.show" class="modal-overlay" @click.self="testAliveModal.show = false">
            <div class="modal modal-lg modal-tall">
                <button class="modal-close-btn" @click="testAliveModal.show = false">Ã—</button>
                <h3 class="modal-title">ğŸ” æµ‹æ´»ç»“æœ - {{ testAliveModal.chatName }}</h3>
                <div class="test-result-content">
                    <div v-if="testAliveModal.loading" class="test-loading">
                        <div class="spinner"></div>
                        <p>æ­£åœ¨æµ‹è¯•...</p>
                    </div>
                    <div v-else-if="testAliveModal.error" class="test-error">
                        <p>âŒ {{ testAliveModal.error }}</p>
                    </div>
                    <div v-else class="test-success">
                        <div class="test-status" :class="testAliveModal.result?.success ? 'success' : 'fail'">
                            <span>{{ testAliveModal.result?.success ? 'âœ… è¿æ¥æ­£å¸¸' : 'âŒ è¿æ¥å¼‚å¸¸' }}</span>
                        </div>
                        <div v-if="testAliveModal.result?.message" class="test-message">
                            <strong>æ¶ˆæ¯ï¼š</strong>{{ testAliveModal.result.message }}
                        </div>
                        <div v-if="testAliveModal.result?.data" class="test-data">
                            <strong>è¿”å›æ•°æ®ï¼š</strong>
                            <pre>{{ JSON.stringify(testAliveModal.result.data, null, 2) }}</pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, reactive, computed, onMounted, onUnmounted, watch, nextTick } = Vue;
        
        // æœåŠ¡é…ç½® - Server ä½¿ç”¨å½“å‰é¡µé¢åœ°å€ï¼ˆé¡µé¢å’Œæ¥å£åœ¨åŒä¸€æœåŠ¡ï¼‰
        const SERVICES = [
            { key: 'server', label: 'Server', host: window.location.origin },
            { key: 'base', label: 'Base', host: 'http://localhost:5000' },
            { key: 'ai', label: 'AI', host: 'https://tl-ai.someget.work' }
        ];
        
        // é»˜è®¤æœåŠ¡åœ°å€ï¼ˆç”¨äº Listen ç­‰æ¥å£ï¼‰
        const SERVER_HOST = SERVICES[0].host;
        
        createApp({
            setup() {
                // Tab state
                const activeTab = ref('list');
                
                // List page state
                const listeners = ref([]);
                const summary = ref({ healthy: 0, unhealthy: 0 });
                const loading = ref(false);
                const loadingItems = reactive({});
                const toasts = ref([]);
                
                const showAddModal = ref(false);
                const newChatName = ref('');
                const addLoading = ref(false);
                const addInput = ref(null);
                
                const confirmModal = reactive({
                    show: false,
                    title: '',
                    message: '',
                    onConfirm: () => {}
                });
                
                const testAliveModal = reactive({
                    show: false,
                    chatName: '',
                    loading: false,
                    error: null,
                    result: null
                });
                
                // Logs page state
                const services = ref(SERVICES);
                const activeService = ref('server');
                const logType = ref('info');
                const logsLoading = ref(false);
                const logsContainer = ref(null);
                const autoScroll = ref(true);
                const isPolling = ref(false);
                let pollTimer = null;
                
                // ä¸ºæ¯ä¸ªæœåŠ¡çš„æ¯ç§æ—¥å¿—ç±»å‹ä¿å­˜çŠ¶æ€
                // key æ ¼å¼: `${service}_${logType}`
                const logsDataMap = reactive({});  // { server_info: { lines: [], offset: 0, initialized: false }, ... }
                
                // è·å–å­˜å‚¨ key
                const getStoreKey = (service, type) => `${service}_${type}`;
                
                // ç¡®ä¿æ•°æ®ç»“æ„å­˜åœ¨
                const ensureLogsData = (service, type) => {
                    const key = getStoreKey(service, type);
                    if (!logsDataMap[key]) {
                        logsDataMap[key] = {
                            lines: [],
                            offset: 0,
                            initialized: false
                        };
                    }
                    return logsDataMap[key];
                };
                
                // å½“å‰æ˜¾ç¤ºçš„æ—¥å¿—è¡Œ
                const currentLogLines = computed(() => {
                    const data = ensureLogsData(activeService.value, logType.value);
                    return data.lines;
                });
                
                const showConfirm = (title, message, onConfirm) => {
                    confirmModal.title = title;
                    confirmModal.message = message;
                    confirmModal.onConfirm = () => {
                        confirmModal.show = false;
                        onConfirm();
                    };
                    confirmModal.show = true;
                };
                
                // Toast
                const showToast = (message, type = 'info') => {
                    const id = Date.now();
                    toasts.value.push({ id, message, type });
                    setTimeout(() => {
                        toasts.value = toasts.value.filter(t => t.id !== id);
                    }, 3000);
                };
                
                // API Request
                const request = async (url, options = {}, host = SERVER_HOST) => {
                    try {
                        const response = await fetch(host + url, {
                            headers: { 'Content-Type': 'application/json' },
                            ...options
                        });
                        const data = await response.json();
                        if (data.code !== 0) {
                            throw new Error(data.message || 'è¯·æ±‚å¤±è´¥');
                        }
                        return data;
                    } catch (error) {
                        if (error.message === 'Failed to fetch') {
                            throw new Error('æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨');
                        }
                        throw error;
                    }
                };
                
                // ==================== List Page Methods ====================
                
                // Fetch Status
                const fetchStatus = async () => {
                    loading.value = true;
                    try {
                        const data = await request('/listen/status');
                        listeners.value = data.data?.listeners || [];
                        summary.value = data.data?.summary || { healthy: 0, unhealthy: 0 };
                    } catch (error) {
                        showToast(error.message, 'error');
                    } finally {
                        loading.value = false;
                    }
                };
                
                // Add Listener
                const addListener = async () => {
                    if (!newChatName.value.trim()) return;
                    
                    addLoading.value = true;
                    try {
                        await request('/listen/add', {
                            method: 'POST',
                            body: JSON.stringify({ chat_name: newChatName.value.trim() })
                        });
                        showToast('æ·»åŠ æˆåŠŸ', 'success');
                        showAddModal.value = false;
                        newChatName.value = '';
                        await fetchStatus();
                    } catch (error) {
                        showToast(error.message, 'error');
                    } finally {
                        addLoading.value = false;
                    }
                };
                
                // Remove Listener
                const removeOne = (chatName) => {
                    showConfirm('åˆ é™¤ç¡®è®¤', `ç¡®å®šè¦åˆ é™¤ã€Œ${chatName}ã€çš„ç›‘å¬å—ï¼Ÿ`, async () => {
                        loadingItems[chatName] = 'remove';
                        try {
                            await request('/listen/remove', {
                                method: 'POST',
                                body: JSON.stringify({ chat_name: chatName })
                            });
                            showToast('åˆ é™¤æˆåŠŸ', 'success');
                            await fetchStatus();
                        } catch (error) {
                            showToast(error.message, 'error');
                        } finally {
                            delete loadingItems[chatName];
                        }
                    });
                };
                
                // Reset One
                const resetOne = async (chatName) => {
                    loadingItems[chatName] = 'reset';
                    try {
                        const data = await request('/listen/reset', {
                            method: 'POST',
                            body: JSON.stringify({ chat_name: chatName })
                        });
                        showToast(data.data?.message || 'é‡ç½®æˆåŠŸ', 'success');
                        await fetchStatus();
                    } catch (error) {
                        showToast(error.message, 'error');
                    } finally {
                        delete loadingItems[chatName];
                    }
                };
                
                // Refresh All
                const refreshAll = async () => {
                    loading.value = true;
                    try {
                        const data = await request('/listen/refresh', { method: 'POST' });
                        const result = data.data;
                        showToast(`åˆ·æ–°å®Œæˆï¼šæˆåŠŸ ${result?.success_count || 0}ï¼Œå¤±è´¥ ${result?.fail_count || 0}`, 'success');
                        await fetchStatus();
                    } catch (error) {
                        showToast(error.message, 'error');
                    } finally {
                        loading.value = false;
                    }
                };
                
                // Reset All
                const resetAll = () => {
                    showConfirm('é‡ç½®ç¡®è®¤', 'ç¡®å®šè¦é‡ç½®æ‰€æœ‰ç›‘å¬å—ï¼Ÿè¿™å°†é‡å¯æ‰€æœ‰ç›‘å¬è¿æ¥ã€‚', async () => {
                        loading.value = true;
                        try {
                            const data = await request('/listen/reset-all', { method: 'POST' });
                            const result = data.data;
                            showToast(result?.message || 'é‡ç½®å…¨éƒ¨å®Œæˆ', 'success');
                            await fetchStatus();
                        } catch (error) {
                            showToast(error.message, 'error');
                        } finally {
                            loading.value = false;
                        }
                    });
                };
                
                // Test Alive - æµ‹æ´»
                const testAlive = async (chatName) => {
                    testAliveModal.show = true;
                    testAliveModal.chatName = chatName;
                    testAliveModal.loading = true;
                    testAliveModal.error = null;
                    testAliveModal.result = null;
                    loadingItems[chatName] = 'test';
                    
                    try {
                        const data = await request('/listen/get-all-message', {
                            method: 'POST',
                            body: JSON.stringify({ chat_name: chatName })
                        });
                        testAliveModal.result = data.data;
                    } catch (error) {
                        testAliveModal.error = error.message;
                    } finally {
                        testAliveModal.loading = false;
                        delete loadingItems[chatName];
                    }
                };
                
                // ==================== Logs Page Methods ====================
                
                // è·å–æœåŠ¡ host
                const getServiceHost = (serviceKey) => {
                    const svc = SERVICES.find(s => s.key === serviceKey);
                    return svc ? svc.host : SERVICES[0].host;
                };
                
                // Fetch logs for a specific service and log type
                const fetchLogsFor = async (serviceKey, type, isInitial = false) => {
                    const data = ensureLogsData(serviceKey, type);
                    const host = getServiceHost(serviceKey);
                    
                    // æ ‡è®°ä¸ºå·²åˆå§‹åŒ–ï¼ˆå³ä½¿è¯·æ±‚å¤±è´¥ä¹ŸåŠ å…¥è½®è¯¢ï¼‰
                    if (isInitial) {
                        data.initialized = true;
                    }
                    
                    try {
                        const offset = isInitial ? 0 : data.offset;
                        const url = `/logs?log_type=${type}&limit=500&since_offset=${offset}`;
                        const result = await request(url, {}, host);
                        
                        if (result.data) {
                            if (isInitial) {
                                data.lines = result.data.lines || [];
                            } else {
                                // å¢é‡è¿½åŠ 
                                const newLines = result.data.lines || [];
                                if (newLines.length > 0) {
                                    data.lines = [...data.lines, ...newLines];
                                }
                            }
                            data.offset = result.data.next_offset || 0;
                            
                            // å¦‚æœæ˜¯å½“å‰æ˜¾ç¤ºçš„ï¼Œè‡ªåŠ¨æ»šåŠ¨
                            if (serviceKey === activeService.value && type === logType.value && autoScroll.value) {
                                nextTick(() => {
                                    scrollToBottom();
                                });
                            }
                        }
                    } catch (error) {
                        console.error(`Fetch logs error for ${serviceKey}/${type}:`, error);
                        // é¦–æ¬¡åŠ è½½æ‰æ˜¾ç¤ºé”™è¯¯
                        if (isInitial && serviceKey === activeService.value && type === logType.value) {
                            showToast(`${serviceKey}: ${error.message}`, 'error');
                        }
                    }
                };
                
                // Fetch current service logs
                const fetchLogs = async (isInitial = false) => {
                    logsLoading.value = true;
                    await fetchLogsFor(activeService.value, logType.value, isInitial);
                    logsLoading.value = false;
                };
                
                // è½®è¯¢æ‰€æœ‰æœåŠ¡çš„ info æ—¥å¿—ï¼ˆerror ä¸è½®è¯¢ï¼Œå¹¶è¡Œè¯·æ±‚ï¼‰
                const pollAllServices = () => {
                    for (const svc of SERVICES) {
                        const data = ensureLogsData(svc.key, 'info');
                        if (data.initialized) {
                            // ä¸ç”¨ awaitï¼Œå¹¶è¡Œè¯·æ±‚å„æœåŠ¡
                            fetchLogsFor(svc.key, 'info', false);
                        }
                    }
                };
                
                // Start polling
                const startPolling = () => {
                    if (pollTimer) return;
                    isPolling.value = true;
                    pollTimer = setInterval(() => {
                        if (activeTab.value === 'logs') {
                            pollAllServices();
                        }
                    }, 5000);
                };
                
                // Stop polling
                const stopPolling = () => {
                    if (pollTimer) {
                        clearInterval(pollTimer);
                        pollTimer = null;
                    }
                    isPolling.value = false;
                };
                
                // Refresh logs (manual) - åªåˆ·æ–°å½“å‰çš„
                const refreshLogs = () => {
                    fetchLogs(false);
                };
                
                // Switch service - é¦–æ¬¡ç‚¹å‡»åˆå§‹åŒ–å¹¶å¼€å¯è½®è¯¢ï¼Œå†æ¬¡ç‚¹å‡»åˆ·æ–°
                const switchService = async (serviceKey) => {
                    const isCurrentService = activeService.value === serviceKey;
                    activeService.value = serviceKey;
                    
                    const infoData = ensureLogsData(serviceKey, 'info');
                    
                    if (!infoData.initialized) {
                        // é¦–æ¬¡ç‚¹å‡»ï¼šåˆå§‹åŒ–å¹¶å¼€å¯è½®è¯¢
                        await fetchLogsFor(serviceKey, 'info', true);
                    } else if (isCurrentService) {
                        // å†æ¬¡ç‚¹å‡»å½“å‰ tabï¼šåˆ·æ–°ï¼ˆå¢é‡æ‹‰å–ï¼‰
                        await fetchLogsFor(serviceKey, 'info', false);
                    }
                    
                    // å¦‚æœå½“å‰é€‰çš„æ˜¯ error ä¸”æœªåˆå§‹åŒ–ï¼Œä¹Ÿæ‹‰å–ä¸€æ¬¡
                    if (logType.value === 'error') {
                        const errorData = ensureLogsData(serviceKey, 'error');
                        if (!errorData.initialized) {
                            await fetchLogsFor(serviceKey, 'error', true);
                        } else if (isCurrentService) {
                            await fetchLogsFor(serviceKey, 'error', false);
                        }
                    }
                    
                    // æ»šåŠ¨åˆ°åº•éƒ¨
                    nextTick(() => {
                        if (autoScroll.value) {
                            scrollToBottom();
                        }
                    });
                };
                
                // Switch log type
                const switchLogType = () => {
                    const data = ensureLogsData(activeService.value, logType.value);
                    if (!data.initialized) {
                        fetchLogs(true);
                    } else {
                        nextTick(() => {
                            if (autoScroll.value) {
                                scrollToBottom();
                            }
                        });
                    }
                };
                
                // Clear current logs display (only UI)
                const clearCurrentLogs = () => {
                    const data = ensureLogsData(activeService.value, logType.value);
                    data.lines = [];
                    // ä¿ç•™ offsetï¼Œç»§ç»­å¢é‡
                };
                
                // Truncate log file on server
                const truncating = ref(false);
                const truncateLogFile = () => {
                    showConfirm(
                        'æ¸…ç©ºæ—¥å¿—æ–‡ä»¶',
                        `ç¡®å®šè¦æ¸…ç©º ${activeService.value.toUpperCase()} æœåŠ¡çš„ ${logType.value.toUpperCase()} æ—¥å¿—æ–‡ä»¶å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼`,
                        async () => {
                            truncating.value = true;
                            try {
                                const host = getServiceHost(activeService.value);
                                const url = `/logs?action=truncate&log_type=${logType.value}`;
                                await request(url, {}, host);
                                
                                // æ¸…ç©ºå½“å‰æ˜¾ç¤ºå¹¶é‡ç½® offset
                                const data = ensureLogsData(activeService.value, logType.value);
                                data.lines = [];
                                data.offset = 0;
                                
                                showToast(`${activeService.value} ${logType.value} æ—¥å¿—å·²æ¸…ç©º`, 'success');
                            } catch (error) {
                                showToast(error.message, 'error');
                            } finally {
                                truncating.value = false;
                            }
                        }
                    );
                };
                
                // Get log level for styling
                const getLogLevel = (line) => {
                    const lowerLine = line.toLowerCase();
                    if (lowerLine.includes('error') || lowerLine.includes('exception') || lowerLine.includes('traceback')) {
                        return 'error';
                    }
                    if (lowerLine.includes('warning') || lowerLine.includes('warn')) {
                        return 'warn';
                    }
                    if (lowerLine.includes('info')) {
                        return 'info';
                    }
                    return '';
                };
                
                // Scroll to bottom
                const scrollToBottom = () => {
                    if (logsContainer.value) {
                        logsContainer.value.scrollTop = logsContainer.value.scrollHeight;
                    }
                };
                
                // Handle logs scroll
                const handleLogsScroll = () => {
                    if (!logsContainer.value) return;
                    const { scrollTop, scrollHeight, clientHeight } = logsContainer.value;
                    autoScroll.value = scrollHeight - scrollTop - clientHeight < 100;
                };
                
                // Toggle auto scroll
                const toggleAutoScroll = () => {
                    autoScroll.value = !autoScroll.value;
                    if (autoScroll.value) {
                        scrollToBottom();
                    }
                };
                
                // ==================== Tab Switch ====================
                
                const switchTab = (tab) => {
                    activeTab.value = tab;

                    if (tab === 'logs') {
                        // è¿›å…¥æ—¥å¿—é¡µé¢ï¼Œç›¸å½“äºç‚¹å‡»ç¬¬ä¸€ä¸ª tabï¼ˆå½“å‰æœåŠ¡ï¼‰
                        switchService(activeService.value);
                        startPolling();
                    } else {
                        stopPolling();
                    }
                };
                
                // Watch modal to focus input
                watch(showAddModal, (val) => {
                    if (val) {
                        nextTick(() => {
                            addInput.value?.focus();
                        });
                    }
                });
                
                // Init
                onMounted(() => {
                    fetchStatus();
                });
                
                // Cleanup
                onUnmounted(() => {
                    stopPolling();
                });
                
                return {
                    // Tab
                    activeTab,
                    switchTab,
                    
                    // List page
                    listeners,
                    summary,
                    loading,
                    loadingItems,
                    toasts,
                    showAddModal,
                    newChatName,
                    addLoading,
                    addInput,
                    confirmModal,
                    testAliveModal,
                    fetchStatus,
                    addListener,
                    removeOne,
                    resetOne,
                    refreshAll,
                    resetAll,
                    testAlive,
                    
                    // Logs page
                    services,
                    activeService,
                    logType,
                    currentLogLines,
                    logsLoading,
                    logsContainer,
                    autoScroll,
                    isPolling,
                    switchService,
                    refreshLogs,
                    switchLogType,
                    clearCurrentLogs,
                    truncating,
                    truncateLogFile,
                    getLogLevel,
                    handleLogsScroll,
                    toggleAutoScroll
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
